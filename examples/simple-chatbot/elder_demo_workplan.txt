read the work plan and the previous chat and the project insights 
i want to know what step in the wokplan are we ? 
and what have we done sofar 


Simple-Chatbot (Pipecat) – Kaizen Work Plan
────────────────────────────────────────────
Gemini Bot Context & API Logic
────────────────────────────────────────────
• This project uses the **Gemini Multimodal Live** bot as the backend LLM.
• All conversation, function-calling, and language handling is routed through Gemini.
• The backend (bot-gemini.py) initializes GeminiMultimodalLiveLLMService with:
    – Hebrew voice (e.g., "Lior")
    – Function tool declarations (for profile, reminders, RAG)
    – Streaming audio and transcript events
• Function-calling is handled per the Gemini API: the model returns a function_call object, the backend executes the function, and the result is sent back as a new message.
• The AI worker must:
    – Understand the Gemini API flow (prompt → function_call → result → response)
    – Ensure all function/tool logic is compatible with Gemini's function-calling schema
    – Ensure all language and TTS/ASR settings are set for Hebrew
    – Validate that the backend and client interact with Gemini as described

Goal
────
Create a demo-ready voice assistant for Hebrew-speaking elderly users that runs on:
• Existing Python FastAPI + Gemini-Live backend
• Existing Android RTVI client

Key MVP Features
• Two hard-coded user profiles (name, age, city, hobbies, pill-time)
• Hebrew conversation (ASR + TTS)
• Gemini Function Calling with three tools:
  – get_profile_field
  – set_medicine_reminder
  – lookup_doc (mini RAG)
• Live Hebrew transcripts on the Android screen
• Keep current robot avatar/audio; no ElevenLabs needed

Kaizen Principles
• Small, always-green commits
• Every step has concrete visual/log validation
• Roll back or fix before moving on
• Use this file as tracker & checklist

Legend
Phase  = high-level milestone
Step   = < 30 min atomic task you can see working
Validation = CLI/log/UI check proving completion

────────────────────────────────────────────
Meta Phase – AI Harness & Validation
────────────────────────────────────
M0.1  Create scripts/validate_phase.sh dispatcher
      Validation: bash scripts/validate_phase.sh 0 prints OK

M0.2  For each phase, create scripts/validate_pX.sh
      Validation: Each script runs, prints PASS/FAIL, and exits 0/1

────────────────────────────────────────────
Phase 0 – Baseline & Branch Setup 🌱
────────────────────────────────────────────
0.1 Create elder_demo_tracker.txt  ✅ *(auto)*
    Validation: test -f elder_demo_tracker.txt

0.2 Baseline run (English)
    • Script: scripts/validate_p0_baseline.sh
      – start server on port 7860
      – curl /connect
      – grep log for "Bot started speaking"
    Validation: harness exits 0

────────────────────────────────────────────
Phase 1 – Profile Injection 👵🏻👴🏽
────────────────────────────────────────────
Reference: See `project_insights.txt` (patient-intake example)
────────────────────────────────────────────
1.1  Add profiles.py in server folder
     - Two dicts: A & B
     - Validation: python -c "import profiles; print(profiles.PROFILES.keys())" | grep a && grep b

1.2  Expose user_id in /connect
     - Modify FastAPI handler
     - Add unit test: tests/test_connect_userid.py
     - Validation: pytest -q tests/test_connect_userid.py

1.3  Inject profile into Gemini system prompt
     - Update bot-gemini.py
     - Log: "Loaded profile: Leah" or "Moshe"
     - Validation: scripts/validate_p1.sh tails log for pattern

1.4  Implement Android profile selection UI
     - Add a profile picker screen in the Android app (Ron/Noam)
     - When user selects a profile, send /connect with user_id ('a' or 'b')
     - Update connection logic to append ?user_id=a or ?user_id=b to backend URL
     - Validation:
         • UI displays both profiles for selection
         • Selecting a profile and connecting loads the correct profile (check backend logs for "Loaded profile: Ron" or "Loaded profile: Noam")
         • Bot responses are personalized to the selected user
         • Switching profiles and reconnecting changes the bot's behavior accordingly

ASK_SUPERVISOR: Please provide the Hebrew greeting text for each profile.

────────────────────────────────────────────
Phase 2 – Function Calling Skeleton 🛠
────────────────────────────────────────────
Reference: See `project_insights.txt` (word-wrangler-gemini-live example)
────────────────────────────────────────────
2.1  Create function_tools.py with medicine reminder schema only
     - Validation: python -c "import function_tools; print(function_tools.medicine_reminder_function)" prints schema

2.2  Implement set_medicine_reminder handler in bot-gemini.py (log params only)
     - Validation: server log shows medicine name and time when function is called

2.3  Add Hebrew system instructions for function calling
     - Validation: LLM asks for missing parameters in Hebrew

2.4  Register function and tools with GeminiMultimodalLiveLLMService
     - Validation: server log shows function call requests

2.5  Test server with sample queries (full, missing name, missing time)
     - Validation: logs show correct function call and parameter prompts

2.6  Show a temporary message (toast/banner) on Android when function call is received
     - Validation: UI briefly displays medicine name and time when function is called

2.7  Test end-to-end: user asks for reminder, bot collects params, logs and UI update
     - Validation: Both server and mobile show correct info

ASK_SUPERVISOR: Confirm Hebrew phrasing for missing parameter prompts and UI display format.

────────────────────────────────────────────
Phase 3 – Hebrew Audio 🎤🔊
────────────────────────────────────────────
Reference: See `project_insights.txt` (translation-chatbot example)
────────────────────────────────────────────
3.1  Select Hebrew voice (e.g. "Lior")
     - Validation: hear Hebrew TTS; log shows correct voice_id

3.2  Tune VAD if needed
     - Validation: no mid-sentence cut-offs in Hebrew test phrase

────────────────────────────────────────────
Phase 4 – On-Screen Transcripts 📝
────────────────────────────────────────────
4.1  Extend VoiceClientManager state lists
     - Validation: logcat prints lines

4.2  ChatTranscript composable in UI
     - Validation: Hebrew text scrolls during chat

────────────────────────────────────────────
Phase 5 – Mini RAG 🔍
────────────────────────────────────────────
Reference: See `project_insights.txt` (news-chatbot example)
────────────────────────────────────────────
5.1  data/knowledge.json with Hebrew Q&A
     - Validation: file exists, valid JSON
5.2  lookup_doc(query) retrieval function
     - Validation: question returns snippet & source (unit test)

────────────────────────────────────────────
Phase 6 – Medicine Reminder ✅
────────────────────────────────────────────
6.1  Add pill_taken_today flag to profile
     - Validation: profile dict updates, test reflects change
6.2  set_medicine_reminder function updates flag
     - Validation: follow-up question reflects update (log/response)

────────────────────────────────────────────
Phase 7 – UX Polish & Demo Script 🎬
────────────────────────────────────────────
7.1  User picker screen (Leah/Moshe)
     - Validation: UI shows both users, selection reflected in answers
7.2  Banner/Toast for latest function result
     - Validation: after tool call, banner shows summary
7.3  run_demo.sh automates server + emulator
     - Validation: script runs, demo completes without crash

────────────────────────────────────────────
Phase 8 – Native Device Actions 📱
────────────────────────────────────────────
8.1  Backend: Define `set_phone_alarm` tool
     - Update `function_tools.py` with the new tool for setting alarms.
     - Validation: Gemini recognizes "set an alarm for 8am" and logs a `function_call` for `set_phone_alarm`.

8.2  Backend: Send RTVI message to client
     - Instead of running Python code, the tool handler will send a custom RTVI message.
     - Example: `{"action": "set_alarm", "time": "08:00"}`
     - Validation: Server log shows the custom message being sent to the client.

8.3  Android: Listen for custom action messages
     - In `VoiceClientManager.kt`, add a listener for incoming RTVI messages.
     - When a message with `{"action": ...}` is received, dispatch it to a handler.
     - Validation: `logcat` shows "Received custom action: set_alarm" with correct parameters.

8.4  Android: Implement native AlarmManager & permissions
     - Create a helper function that calls Android's `AlarmManager`.
     - Add necessary permissions to `AndroidManifest.xml`.
     - Implement the runtime permission request flow.
     - Validation: After granting permission, the alarm is visible in the Android Clock app.

ASK_SUPERVISOR: Confirm the exact format for the RTVI message and the desired user experience for permissions (e.g., should we ask once, or every time?).

────────────────────────────────────────────
Possible Issues & Troubleshooting
────────────────────────────────────────────
• Daily API or token errors: check .env and network connectivity
• Gemini API quota or Hebrew voice not available: check API key, try fallback voice
• Android app not connecting: check backend URL, logs, and network
• Function call not triggered: check tool declaration, logs, and Gemini model support
• RAG/knowledge base not returning: check JSON validity, retrieval logic
• TTS/ASR not in Hebrew: check voice_id, language settings, and logs
• If any validation fails or requirements are unclear, the AI must PAUSE and ASK_SUPERVISOR for help before proceeding.

────────────────────────────────────────────
End-State ✅
───────────
• Hebrew personalised conversation with transcripts
• Function calls hit Python handlers
• Knowledge lookup works; medicine reminder stateful
• Switch between User A & B proves personalisation
• Tracker empty, logs green 

─────────────────────────────────────────────
New Insights & Lessons Learned (2025-06-09)
─────────────────────────────────────────────
• Each /connect call creates a new Daily room and token, ensuring session isolation and preventing cross-talk between users.
• The server enforces a maximum of one bot per room and cleans up bot processes on shutdown.
• For local development, you can set DAILY_SAMPLE_ROOM_URL to reuse a room, but for production/demo, always create a new room per session.
• If you see 'address already in use' errors, check for existing server processes on the same port.
• If room creation fails, verify your DAILY_API_KEY and network connectivity.
• The user_id parameter in /connect is critical: it must be 'a' or 'b'. If an invalid user_id is provided, the server returns a clear error. This prevents accidental misconfiguration and ensures the correct profile is loaded.
• Always check logs for 'Room URL:' and 'Loaded profile:' to verify correct setup.
• If you see errors about 'Client already in a call', ensure the Daily room is not being reused by multiple clients simultaneously.
• The profile system is now robust: the selected profile is injected into the Gemini system prompt, and the bot personalizes its responses accordingly. 

─────────────────────────────────────────────
Profile Parameter Issue: Lessons & Insights (2025-06-10)
─────────────────────────────────────────────
Problem
───────
When the /connect endpoint was updated to require a user_id parameter (to select a user profile), the Android client did not send this parameter. This caused a 422 Unprocessable Entity error, breaking the connection flow.

What We Learned
───────────────
• API Contract Changes: Any change to required API parameters must be reflected in all clients, or the backend must provide a default for backward compatibility.
• FastAPI Validation: FastAPI enforces required parameters strictly. Missing required parameters result in a 422 error.
• Backward Compatibility: Making new parameters optional (with a sensible default) prevents breaking existing clients.
• Clear Error Messages: The backend should return clear, actionable error messages for invalid or missing parameters.

Insights for Future Problem-Solving
───────────────────────────────────
• Document all API changes and communicate them to client developers.
• Add strict validation and clear error handling for all user-facing parameters.
• When introducing new parameters, consider the impact on all clients and provide defaults if possible.
• Always test the full client-server flow after backend changes, not just the backend in isolation.
• Update documentation and work plans immediately after resolving such issues, so future developers avoid similar pitfalls. 

─────────────────────────────────────────────
Insights & Lessons Learned (2025-07-10)
─────────────────────────────────────────────
• Breaking down function calling into atomic steps (schema, handler, registration, UI) makes debugging and validation easier.
• Always validate function schemas in isolation before integrating with LLM service.
• Use clear, language-specific system instructions to guide the LLM on when and how to use function tools.
• Log all function call parameters for easy debugging and validation.
• Android client must display function call stubs for user feedback, not just rely on server logs.
• Test with both complete and incomplete user queries to ensure the bot collects all required parameters interactively.
• Confirm all Hebrew prompts and UI text with supervisor for best user experience. 